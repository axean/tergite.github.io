---
title: "Quick Start"
---

Let's attempt to setup the Tergite stack to run on a simulator on your local
machine.

We will not need an actual quantum computer.

## Prerequisites

You may have to install these software if you don't have them already installed.

- [Docker +v23.0.5](https://www.docker.com/products/docker-desktop/)
- [Conda](https://docs.anaconda.com/free/miniconda/index.html)
- [Redis](https://redis.io/docs/latest/operate/oss_and_stack/install/install-redis/)
- [MongoDb](https://www.mongodb.com/docs/manual/administration/install-community/)
- [Visual Studio Code](https://code.visualstudio.com/download)
- [Mongo compass](https://www.mongodb.com/docs/compass/current/install/)

## Setup the Backend

- Ensure you have [conda](https://docs.anaconda.com/free/miniconda/index.html) installed. 
 (_You could simply have python +3.9 installed instead._)
- Ensure you have the [Redis](https://redis.io/) server running. 

```zsh
redis-server
```

- Open terminal. 
- Clone the [tergite-backend](https://github.com/tergite/tergite-backend) repo

```zsh
git clone https://github.com/tergite/tergite-backend.git
```

- Create conda environment

```zsh
conda create -n bcc -y python=3.9
conda activate bcc
```

- Install dependencies

```zsh
cd tergite-backend
pip install -r requirements.txt
```

- Copy the template for the `.env` file

```zsh
cp dot-env-template.env .env
```

- Update the following values in the `.env` file e.g. with visual studio code (or any other text editor).

```zsh
code .env
```

- Update following variables in the `.env` to:

```zsh
DEFAULT_PREFIX=qiskit_pulse_1q

BCC_MACHINE_ROOT_URL=http://localhost:8000
BCC_PORT=8000

MSS_MACHINE_ROOT_URL=http://localhost:8002
MSS_PORT=8002

EXECUTOR_TYPE=qiskit_pulse_1q

IS_AUTH_ENABLED=False
APP_SETTINGS=development
```

- Run start script

```zsh
./start_bcc.sh --device configs/device_default.toml
```

- Open your browser at [http://localhost:8000/docs](http://localhost:8000/docs){.external target="_blank"} to see the interactive API docs

## Setup the Frontend

- Ensure you have [docker](https://docs.docker.com/engine/install/) is running.

```zsh
docker --help
```

- Open another terminal

- Clone the [tergite-frontend](https://github.com/tergite/tergite-frontend) repo

```zsh
git clone https://github.com/tergite/tergite-frontend.git
```

- Enter the tergite-frontend folder

```zsh
cd tergite-frontend
```

- Create an `mss-config.toml` file with visual studio code (or any other text editor).

```zsh
code mss-config.toml
```

- Update the `mss-config.toml` with the following content

```toml
# mss-config.toml

# general configurations
[general]
# the port on which MSS is running
mss_port = 8002
# the port on which the websocket is running
ws_port = 6532
# environment reflect which environment the app is to run in.
environment = "development"
# the host the uvicorn runs on.
# During testing auth on 127.0.0.1, set this to "127.0.0.1". default: "0.0.0.0"
mss_host = "127.0.0.1"

[database]
# configurations for the database
name = "testing"
# database URI
# host.docker.internal resolves to the host's 127.0.0.1
# see https://stackoverflow.com/questions/31324981/how-to-access-host-port-from-docker-container#answer-43541732
url = "mongodb://host.docker.internal:27017"

[[backends]]
name = "qiskit_pulse_1q"
# the URL where this backend is running
# host.docker.internal resolves to the host's 127.0.0.1
# see https://stackoverflow.com/questions/31324981/how-to-access-host-port-from-docker-container#answer-43541732
url = "http://host.docker.internal:8000"

[auth]
# turn auth OFF or ON, default=true
is_enabled = false
cookie_domain = "127.0.0.1"
cookie_name = "tergiteauth"

[[auth.clients]]
name = "github"
client_id = "some-github-obtained-client-id"
client_secret = "some-github-obtained-client-secret"
redirect_url = "http://127.0.0.1:8002/auth/app/github/callback"
client_type = "github"
email_regex = "^(john\\.doe|jane|aggrey)@example\\.com$"
email_domain = "example.com"
roles = ["admin", "user"]

[[auth.clients]]
name = "puhuri"
client_id = "some-puhuri-obtained-client-id"
client_secret = "some-puhuri-obtained-client-secret"
redirect_url = "http://127.0.0.1:8002/auth/app/puhuri/callback"
client_type = "openid"
email_regex = "^(john\\.doe|jane)@example\\.com$"
email_domain = "example.com"
roles = ["user"]
openid_configuration_endpoint = "https://proxy.acc.puhuri.eduteams.org/.well-known/openid-configuration"

# Puhuri synchronization
# Puhuri is a resource management platform for HPC systems, that is also to be used for Quantum Computer's
[puhuri]
# turn puhuri synchronization OFF or ON, default=true
is_enabled = false
```

- Create a `.env` file with visual studio code (or any other text editor).

```zsh
code .env
```

- Update the `.env` with the following content

```zsh
# .env

# required
ENVIRONMENT="development"
MSS_V2_API_URL="http://127.0.0.1:8002/v2"
GRAFANA_LOKI_URL=http://127.0.0.1:3100/loki/api/v1/push
LOKI_LOGGER_ID=some-generic-id

# docker LOGGING_DRIVER can be journald, json-file, local etc. 
LOGGING_DRIVER=json-file
# image versions:
# Note: If you ever want the images to be rebuilt, 
# you have to change the app version numbers here 
# before running "docker compose up"
MSS_VERSION=v0.0.1
DASHBOARD_VERSION=v0.0.1
PROMTAIL_VERSION=2.8.3
```

- Open the Mongo compass application and connect to the default local mongo database

::: {layout-ncol=1}
![](../assets/img/tutorials/quick_start/mongo-compass-new-connection.png)
:::

- Create a new mongo database called "testing" that contains a "backends" collection.

::: {layout-ncol=1}
![](../assets/img/tutorials/quick_start/mongo-compass-new-database-collection.png)
:::

- Create another mongodb collection called 'devices' in the same database

::: {layout-ncol=1}
![](../assets/img/tutorials/quick_start/mongo-compass-create-devices-collection.png)
:::

- Create another mongodb collection called 'calibrations_v2' in the same database

::: {layout-ncol=1}
![](../assets/img/tutorials/quick_start/mongo-compass-create-calibrations-v2-collection.png)
:::

- These databases are required to be in place as soon as we want to push the simulator configuration

- Delete the old docker images of "tergite/tergite-mss", "tergite/tergite-dashboard" from docker if they exist.

```zsh
docker rmi tergite/tergite-mss:v0.0.1
docker rmi tergite/tergite-dashboard:v0.0.1
```

- To Run the services, use the `fresh-docker-compose.yml`.

```zsh
docker compose -f fresh-docker-compose.yml up -d
```

- Open your browser at

  - [http://localhost:8002](http://localhost:8002){.external target="_blank"} to see the MSS service
  - [http://localhost:3000](http://localhost:3000){.external target="_blank"} to see the Dashboard application

- To view the status of the services, run:

```zsh
docker compose -f fresh-docker-compose.yml ps
```

- To stop the services, run:

```zsh
docker compose -f fresh-docker-compose.yml stop
```

- To remove stop the services and remove their containers also, run:

```zsh
docker compose -f fresh-docker-compose.yml down
```

- To view logs of the docker containers to catch some errors, use:

```zsh
docker compose -f fresh-docker-compose.yml logs -f
```

_see more at https://docs.docker.com/reference/cli/docker/compose/logs/_

- Ensure that the services are running. If they are not, restart them.

```zsh
docker compose -f fresh-docker-compose.yml up -d
```

## Push the simulator configuration to the database

- Before we can connect our simulator, we have to push the configuration for the simulator to the database

- Go to the folder where you installed the backend

```zsh
cd tergite-backend
```

- Activate the conda environment for your backend and install the backend

```zsh
conda activate bcc
pip install -e .
```

- Run the script that pushes the configuration to the database

```zsh
python app/scripts/push_simulator_to_db.py
```


## Run an Experiment

- Open another terminal

- Create a new folder "tergite-test" and enter it

```zsh
mkdir tergite-test
cd tergite-test
```

- Create conda environment and activate it

```zsh
conda create -n tergite -y python=3.9
conda activate tergite
```

- Install [qiskit](https://github.com/Qiskit/qiskit) and [tergite SDK](https://github.com/tergite/tergite) by running the command below:


```zsh
pip install qiskit
pip install tergite
```

- Create a file `main.py` with visual studio code (or any other text editor).

```zsh
code main.py
```

- Update the `main.py` file with the following content:

```python
# main.py
"""A sample script doing a very simple quantum operation"""
import time

import qiskit.circuit as circuit
import qiskit.compiler as compiler

from tergite.qiskit.providers import Job, Tergite
from tergite.qiskit.providers.provider_account import ProviderAccount

if __name__ == "__main__":
    # the Tergite API URL
    API_URL = "http://localhost:8002"
    # The name of the Quantum Computer to use from the available quantum computers
    BACKEND_NAME = "qiskit_pulse_1q"
    # the name of this service. For your own bookkeeping.
    SERVICE_NAME = "local"
    # the timeout in seconds for how long to keep checking for results
    POLL_TIMEOUT = 100

    # create the Qiskit circuit
    qc = circuit.QuantumCircuit(1)
    qc.x(0)
    qc.h(0)
    qc.measure_all()

    # create a provider
    # provider account creation can be skipped in case you already saved
    # your provider account to the `~/.qiskit/tergiterc` file.
    # See below how that is done.
    account = ProviderAccount(service_name=SERVICE_NAME, url=API_URL)
    provider = Tergite.use_provider_account(account)
    # to save this account to the `~/.qiskit/tergiterc` file, add the `save=True`
    # provider = Tergite.use_provider_account(account, save=True)

    # Get the tergite backend in case you skipped provider account creation
    # provider = Tergite.get_provider(service_name=SERVICE_NAME)
    backend = provider.get_backend(BACKEND_NAME)
    backend.set_options(shots=1024)

    # compile the circuit
    tc = compiler.transpile(qc, backend=backend)

    # run the circuit
    job: Job = backend.run(tc, meas_level=2, meas_return="single")

    # view the results
    elapsed_time = 0
    result = None
    while result is None:
        if elapsed_time > POLL_TIMEOUT:
            raise TimeoutError(
                f"result polling timeout {POLL_TIMEOUT} seconds exceeded"
            )

        time.sleep(1)
        elapsed_time += 1
        result = job.result()

    print(result.get_counts())
```

- Execute the above script by running the command below.

```zsh
python main.py
```

- It should return something like:

```zsh
Results OK
{'0': 776, '1': 248}
```